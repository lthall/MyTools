function [ Body_X, Body_Y, Body_Z, DCM_EB ] = Vector_Earth2Body( Roll_A, Pitch_A, Yaw_A,  Earth_X, Earth_Y, Earth_Z  )
%VECTOR_BODY2EARTH Summary of this function goes here
%   Detailed explanation goes here

% Body_X = Earth_X * cos(Pitch_A) * cos(Yaw_A) ...
%     + Earth_Y * (cos(Pitch_A) * sin(Yaw_A)) ...
%     - Earth_Z * sin(Pitch_A);
% 
% Body_Y = Earth_X * (-cos(Roll_A) * sin(Yaw_A) + sin(Roll_A) * sin(Pitch_A) * cos(Yaw_A)) ...
%     + Earth_Y * (cos(Roll_A) * cos(Yaw_A) + sin(Roll_A) * sin(Pitch_A) * sin(Yaw_A)) ...
%     + Earth_Z * sin(Roll_A) * cos(Pitch_A);
% 
% Body_Z = Earth_X * (sin(Roll_A) * sin(Yaw_A) + cos(Roll_A) * sin(Pitch_A) * cos(Yaw_A)) ...
%     + Earth_Y * (-sin(Roll_A) * cos(Yaw_A) + cos(Roll_A) * sin(Pitch_A) * sin(Yaw_A)) ...
%     + Earth_Z * cos(Roll_A) * cos(Pitch_A);

DCM_EB = [cos(Pitch_A) * cos(Yaw_A), ...
    (cos(Pitch_A) * sin(Yaw_A)), ...
    - sin(Pitch_A); ... 
    ...
    (-cos(Roll_A) * sin(Yaw_A) + sin(Roll_A) * sin(Pitch_A) * cos(Yaw_A)), ...
    (cos(Roll_A) * cos(Yaw_A) + sin(Roll_A) * sin(Pitch_A) * sin(Yaw_A)), ...
    sin(Roll_A) * cos(Pitch_A); ...
    ...
    (sin(Roll_A) * sin(Yaw_A) + cos(Roll_A) * sin(Pitch_A) * cos(Yaw_A)), ...
    (-sin(Roll_A) * cos(Yaw_A) + cos(Roll_A) * sin(Pitch_A) * sin(Yaw_A)), ...
    cos(Roll_A) * cos(Pitch_A)];
    
    Body_XYZ = DCM_EB * [Earth_X; Earth_Y; Earth_Z];
    
    Body_X = Body_XYZ(1);
    Body_Y = Body_XYZ(2);
    Body_Z = Body_XYZ(3);
end